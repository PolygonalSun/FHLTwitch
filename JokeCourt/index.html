<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <title>Joke Court!</title>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <meta name="description" content="Babylon.js scene demonstrating how to use twitch integration with a 3d generated elements">
  <meta name="keywords" content="Babylon.js, OBS, streamer, twitch, joke">

  <meta name="obs-width" content="1920">
  <meta name="obs-height" content="1080">
  <meta name="obs-fps" content="60">
  <meta name="obs-shutdown" content="true">
  <meta name="obs-refresh" content="false">

  <meta name="obs-browser" content="width=1920,height=1080,fps=60,shutdown=true,refresh=false">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

  <style>
    /* Style reset */
    /* http://meyerweb.com/eric/tools/css/reset/
       v2.0 | 20110126
       License: none (public domain)
    */

    html, body, div, span, applet, object, iframe,
    h1, h2, h3, h4, h5, h6, p, blockquote, pre,
    a, abbr, acronym, address, big, cite, code,
    del, dfn, em, img, ins, kbd, q, s, samp,
    small, strike, strong, sub, sup, tt, var,
    b, u, i, center,
    dl, dt, dd, ol, ul, li,
    fieldset, form, label, legend,
    table, caption, tbody, tfoot, thead, tr, th, td,
    article, aside, canvas, details, embed,
    figure, figcaption, footer, header, hgroup,
    menu, nav, output, ruby, section, summary,
    time, mark, audio, video {
        margin: 0;
        padding: 0;
        border: 0;
        font-size: 100%;
        font: inherit;
        vertical-align: baseline;
    }
    /* HTML5 display-role reset for older browsers */
    article, aside, details, figcaption, figure,
    footer, header, hgroup, menu, nav, section {
        display: block;
    }
    body {
        line-height: 1;
    }
    ol, ul {
        list-style: none;
    }
    blockquote, q {
        quotes: none;
    }
    blockquote:before, blockquote:after,
    q:before, q:after {
        content: '';
        content: none;
    }
    table {
        border-collapse: collapse;
        border-spacing: 0;
    }
    /* End of style reset */

    body {
        font-family: "Open Sans", sans-serif;
        color: white;
    }

    p + h1, p + h2, p + h3, p + h4, p + h5 {
        margin-top: 32px;
    }

    p + p {
        margin-top: 24px;
    }

    .main_slant {
        position: absolute;
        width: 200%;
        left: -50%;
    }

    #bg_slant1 {
        left: -80%;
        bottom: -20%;
        height: 75%;
        width: 250%;
        background: #202d6f;
        transform: rotate(15deg);
    }

    #bg_slant2 {
        height: 200px;
        background: #1c2b71;
        transform: rotate(1deg);
        top: -50px;
    }

    #bg_slant3 {
        height: 500px;
        background: #0C1633;
        transform: rotate(-8deg);
        bottom: -200px;
    }

    .bs-page {
        background: #16245800;
        font-size: 24px;
        position: relative;
        line-height: 30px;
        text-align: center;
        padding: 0%;
        width: 100vw;
        height: 100vh;
        box-sizing: border-box;
        overflow: hidden;
    }

    .bs-container {
        position: relative;
        max-width: 800px;
        margin: 0px auto;
    }

    .bs-image {
        display: block;
        margin: 40px;
        margin: 40px auto;
    }

    .fill-container {
        width: 100%;
        height: 100%;
    }
  </style>

    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/recast.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/BabylonJS/Extensions@master/MeshWriter/meshwriter.min.js"></script>
    <script src="../scripts/tmi.min.js"></script>
    <script src="../src/Receivers/relayReceiver.js"></script>
    <script src="../src/Receivers/tmiReceiver.js"></script>
</head>

<body>
    <script src="../src/judgeReceiver.js"></script>
    <div id="wrapper">

        <div class="bs-page">
            <canvas id="bjsCanvas"; class="fill-container"></canvas>
        </div>
    </div>

<script>
    var canvas = document.getElementById("bjsCanvas"); // Get the canvas element
    var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine
    var _elapsedTime = 0; // how much time has passed since the scene began?

    var _badPercent = 0; // what percent of the votes are bad?
    var _goodPercent = 0; // what percent of the votes are good?

    /******* Add the create scene function ******/
    var createScene = function () {
        let scene = new BABYLON.Scene(engine);
        scene.clearColor = new BABYLON.Color4(0, 0, 0, 0);

        // setup the main camera for the scene and give it control limits
        let mainCam = new BABYLON.ArcRotateCamera("mainCam", BABYLON.Tools.ToRadians(-90), BABYLON.Tools.ToRadians(90), 10, new BABYLON.Vector3(0, 0, 0), scene);
        mainCam.attachControl(canvas, true);

        var make3dText = function(text, scene, scaleX, scaleY, color, height, thickness, position, anchor, textMeshMaxWidth) {
            const Writer = BABYLON.MeshWriter(scene, {scaleX:scaleY});
            const textWriter = new Writer(
                text,
                {
                    "anchor": anchor,
                    "letter-height": height,
                    "color": "#FFFFFF",
                    "letter-thickness": thickness,
                    "position": {
                        x : position.x,
                        y : position.y,
                        z : position.z
                    }
                }
            );
            textWriter.getMesh().rotate(BABYLON.Vector3.Right(), -Math.PI/2);
            setTextColor(textWriter, color);

            // TODO: Hacky fix to get text to fit within the bounds we want. We should instead be breaking up the text into multiple meshes, and parenting them to a shared transform.
            if (textMeshMaxWidth){
                const textMeshMinMax = BABYLON.Mesh.MinMax([textWriter.getMesh()]);
                textWriter.getMesh().scaling.x = Math.min(1, textMeshMaxWidth/(textMeshMinMax.max.x - textMeshMinMax.min.x));
            }
            return textWriter;
        }

        /* simple two color bar graph creator using emissives */
        var makeBarGraph = function(text, scene, scale, textColor, textHeight, textThickness, textOffset, barHeight, barWidth, barDepth, barColor, barBackgroundColor, barMaxValue) {
            let barGraphHandle = new BABYLON.TransformNode();
            let barText = make3dText(text, scene, scale, scale, textColor, textHeight, textThickness, textOffset.clone().addInPlaceFromFloats(-barWidth/2, 3*barHeight/4, 0), "left");
            barText.getMesh().setParent(barGraphHandle);
            let barMesh = BABYLON.MeshBuilder.CreateBox("graphBox", {height: barHeight, width: barWidth, depth: barDepth}, scene);
            let barFillPlane = BABYLON.MeshBuilder.CreatePlane("graphBoxFill", {height: barHeight, width: barWidth}, scene);
            barMesh.setParent(barGraphHandle);
            barFillPlane.setParent(barGraphHandle);
            let barMeshMaterial = new BABYLON.PBRMaterial("barGraphMaterial", scene);
            let barBackPlaneMaterial = new BABYLON.PBRMaterial("barGraphFillMaterial", scene);
            barMesh.material = barMeshMaterial;
            barFillPlane.material = barBackPlaneMaterial;
            barMeshMaterial.emissiveColor.copyFrom(barColor);
            barBackPlaneMaterial.emissiveColor.copyFrom(barBackgroundColor);

            // Modify the vertex data such that the origin is in the left face.
            barMesh.position.addInPlaceFromFloats(barWidth/2, 0, 0);
            barMesh.bakeCurrentTransformIntoVertices();
            barMesh.position.addInPlaceFromFloats(-barWidth/2, 0, 0);

            // Move the fill plane to be aligned with the back face of the bar graph
            barFillPlane.position.addInPlaceFromFloats(0, 0, barDepth/2);

            let setBarValue = (value) => {
                barMesh.scaling.x = (value / barMaxValue)
            }
            return {handle: barGraphHandle, text: barText, barMesh: barMesh, barFillPlane: barFillPlane, setValue: setBarValue};
        }

        var makeTextShaky = function(text, yFactor, ySpeed) {
            console.log("Setting shaky text!");
            text.getSPS().updateParticle = (particle) => {
                particle.position.copyFromFloats(particle.position.x, particle.position.y, yFactor * Math.random());
            }
        }

        var setTextColor = function(text, color){
            text.getSPS().particles.forEach(particle => {
                particle.color.r = color.r;
                particle.color.g = color.g;
                particle.color.b = color.b;
                particle.color.a = color.a;
            })
        }

        var makeTextExplodey = function(text, deltaAng, xForce, yForce, gravity) {
            console.log("Setting explodey text");
            text.getSPS().initParticles = function (deltaAng, xForce, yForce) {
                for (var p = 0; p < this.nbParticles; p++){
                    // generate a random vector within the upward hemisphere to send this particle.
                    let angX = deltaAng * (Math.random() - 0.5);
                    let angY = deltaAng * Math.random();
                    this.particles[p].velocity.copyFromFloats(Math.cos(angX) * xForce, Math.sin(angX) * xForce, Math.cos(angY)  * yForce);
                }
            }
            text.getSPS().initParticles(deltaAng, xForce, yForce);
            text.getSPS().updateParticle = (particle) => {
                console.log("Updating explodeyText!")
                particle.velocity.z += gravity;
                (particle.position).addInPlace(particle.velocity);
            }
        }

        /* setup default formatting values */
        let textScale = 1;

        let offenderTextColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);
        let offenderTextHeight = 0.5;
        let offenderTextThickness = 0.001;
        let offenderTextPosition = new BABYLON.Vector3(-7.3, -0.75, 0);
        let offenderTextAlignmentString = "left";
        let offenderTextMaxWidth = 3.6;

        let jokeTextColor = new BABYLON.Color4(0.9, 0.9, 0.9, 1);
        let jokeTextHeight = 1;
        let jokeTextThickness = 0.001;
        let jokeTextPosition = new BABYLON.Vector3(-7, -2, 0);
        let jokeTextAlignmentString = "left";
        let jokeTextMaxWidth = 14;

        /* Initialize placeholders for help formatting */
        let jokePlaceholderText = "Why did the chicken cross the road? Because there was a crosswalk.";
        let offenderPlaceholderText = "whoisdrigax199292"
        /* we probably want to implement some sort of word-wrap solution based on the maximum acceptible width of a line */
        let jokeTextMesh = make3dText(jokePlaceholderText, scene, textScale, textScale, jokeTextColor, jokeTextHeight, jokeTextThickness, jokeTextPosition, jokeTextAlignmentString, jokeTextMaxWidth);
        let offenderTextMesh = make3dText(offenderPlaceholderText, scene, textScale, textScale, offenderTextColor, offenderTextHeight, offenderTextThickness, offenderTextPosition, offenderTextAlignmentString, offenderTextMaxWidth);
        let barGraphGuilty = makeBarGraph("Bad Joke", scene, 1, new BABYLON.Color4(0,1,0,0), 0.25, 0.001, new BABYLON.Vector3(0, 0, 0), 0.5, 2, 0.5, new BABYLON.Color3(0, 1, 0), new BABYLON.Color3(1, 0, 0), 1);
        let barGraphNotGuilty = makeBarGraph("Good Joke", scene, 1, new BABYLON.Color4(0,1,0,0), 0.25, 0.001, new BABYLON.Vector3(0, 0, 0), 0.5, 2, 0.5, new BABYLON.Color3(0, 1, 0), new BABYLON.Color3(1, 0, 0), 1);

        barGraphGuilty.handle.position.copyFromFloats(4, 3.5, 0);
        barGraphNotGuilty.handle.position.copyFromFloats(4, 2.5, 0);

        barGraphGuilty.setValue(0.25);
        barGraphNotGuilty.setValue(0.75);

        displayStringOnTrial = () => {
            if (jokeTextMesh) {
                jokeTextMesh.getMesh().dispose();
                jokeTextMesh = null;
            }
            if (offenderTextMesh) {
                offenderTextMesh.getMesh().dispose();
                offenderTextMesh = null;
            }

            jokeTextMesh = make3dText(_stringOnTrial, scene, textScale, textScale, jokeTextColorHex, jokeTextHeight, jokeTextThickness, jokeTextPosition, jokeTextAlignmentString);
            offenderTextMesh = make3dText(_offender, scene, textScale, textScale, offenderTextColorHex, offenderTextHeight, offenderTextThickness, offenderTextPosition, offenderTextAlignmentString);
        }

        sentenceGuilty = () => {
            console.log("Guilty!");
            makeTextShaky(jokeTextMesh, 0.1, 0.01);
            setTextColor(jokeTextMesh, new BABYLON.Color4(1.0,0.1,0.1,1));
            let explosionTimer = setInterval(() => {
                clearInterval(explosionTimer);
                makeTextExplodey(jokeTextMesh, Math.PI, 0.2, 1.0, -0.05);
            }, 2000);
            /* maybe add some additional 3d effect with a gavel? */
        }

        sentenceNotGuilty = () => {
            console.log("Not Guilty!");
        }

        onVotesChanged = () => {
            console.log("Updating vote display...");
            const voteCount = votesGuilty+votesNotGuilty
            _badPercent = voteCount != 0 ? votesGuilty/voteCount : 0
            _goodPercent = voteCount != 0 ? votesNotGuilty/voteCount : 0
            barGraphGuilty.setValue(_badPercent);
            barGraphNotGuilty.setValue(_goodPercent);
        }

        scene.onBeforeRenderObservable.add(() => {
            jokeTextMesh.getSPS().setParticles();
            offenderTextMesh.getSPS().setParticles();
            barGraphGuilty.text.getSPS().setParticles();
            barGraphNotGuilty.text.getSPS().setParticles();
            _elapsedTime += engine.getDeltaTime();
        })

         // Test effects here...
        let testTimer = setInterval(() => {
            clearInterval(testTimer);
            sentenceGuilty();
        }, 2000);


        /* return the initialized scene */
        return scene;
    }


    /******* End of the create scene function ******/
    var scene = createScene(); //Call the createScene function

    // Register a render loop to repeatedly render the scene
    engine.runRenderLoop(function () {
            scene.render();
    });

    // Watch for browser/canvas resize events
    window.addEventListener("resize", function () {
            engine.resize();
    });
</script>

</body>